<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 2</title>
    <meta charset="utf-8" />
    <meta name="author" content="Michal Kubišta" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Lecture 2
### Michal Kubišta
### 2020/10/07

---


## Structure
- Data &amp; Variable types
- Arithmetic &amp; logic operators
- Subsetting (slicing)

---
class: middle, inverse

# Data &amp; Variable types

---

## Variables
--

- any text that is not enclosed in "" or ''
- without brackets at the end, e.g. test()
- not predefined words


```r
"number"
```

```
## [1] "number"
```

```r
number = 5
number
```

```
## [1] 5
```

```r
"text"
```

```
## [1] "text"
```

```r
text &lt;- 'R is amazing'
print(text)
```

```
## [1] "R is amazing"
```

---

## Data types
--


```r
input
"text"
1.5
20L
TRUE
FALSE
Sys.Date()
Sys.time()
0 / 0
```

---
## Data types cont.


```r
input # variable (not an actual data type)
"text" # character
1.5 # numeric
20L # integer
TRUE #boolean
```

```r
Sys.Date() # Date
```

```
## [1] "2020-10-07"
```

```r
Sys.time() # POSIXct POSIXlt
```

```
## [1] "2020-10-07 15:55:29 CEST"
```

```r
NA; 0 / 0 # this is bad idea
```

```
## [1] NA
```

```
## [1] NaN
```

---

## Casting
- how to change data types?


```r
as.character(1)
```

```
## [1] "1"
```

```r
as.numeric("1")
```

```
## [1] 1
```

```r
as.integer(1.5)
```

```
## [1] 1
```

---
## Data structures
- what a variable can be?



--
- vector

--
- matrix

--
- list

--
- data frame

---

## Vectors


```r
c(2, 5)
```

```
## [1] 2 5
```

```r
c(8, 25, 3.14, -4)
```

```
## [1]  8.00 25.00  3.14 -4.00
```

```r
c('R', 'S')
```

```
## [1] "R" "S"
```

```r
c(25, T, 'a') # T is the same as TRUE
```

```
## [1] "25"   "TRUE" "a"
```

```r
2:6
```

```
## [1] 2 3 4 5 6
```

---

## Factors - special data type


```r
fac = factor(c('a','a','b','c'), levels = c("a","b","c"))
fac
```

```
## [1] a a b c
## Levels: a b c
```

```r
as.numeric(fac)
```

```
## [1] 1 1 2 3
```

---

## Matrices


```r
matrix(c(2, 5))
```

```
##      [,1]
## [1,]    2
## [2,]    5
```

```r
matrix(c(8, 25, 3.14, -4), nrow = 2)
```

```
##      [,1]  [,2]
## [1,]    8  3.14
## [2,]   25 -4.00
```

```r
matrix(c('R', 'S', 'C', 'Py', 'C', 'J'), ncol = 3, byrow = TRUE)
```

```
##      [,1] [,2] [,3]
## [1,] "R"  "S"  "C" 
## [2,] "Py" "C"  "J"
```

---

## Matrices cont.


```r
matrix(c('R', 5, 'C', NA, Sys.Date() , T), nrow = 3, ncol = 2)
```

```
##      [,1] [,2]   
## [1,] "R"  NA     
## [2,] "5"  "18542"
## [3,] "C"  "TRUE"
```

---

## Data frames


```r
input = data.frame(wage = c(1:3), gender = c("male", "female", NA))
input
```

```
##   wage gender
## 1    1   male
## 2    2 female
## 3    3   &lt;NA&gt;
```

```r
rownames(input)
```

```
## [1] "1" "2" "3"
```

```r
colnames(input)
```

```
## [1] "wage"   "gender"
```

---

## Data frames cont.


```r
output = data.frame(wage = c(1 , 2, NA, Sys.time(), 'not avaliable'))
```

--


```r
output
```

```
##               wage
## 1                1
## 2                2
## 3             &lt;NA&gt;
## 4 1602078929.65558
## 5    not avaliable
```

---

## Lists


```r
list(125, "R is good")
```

```
## [[1]]
## [1] 125
## 
## [[2]]
## [1] "R is good"
```

```r
list(onetyone = 11, zwoelf = "12")
```

```
## $onetyone
## [1] 11
## 
## $zwoelf
## [1] "12"
```

```r
list(a = c(1:5))
```

```
## $a
## [1] 1 2 3 4 5
```

---

## Lists cont.


```r
list(WT = data.frame(NUM = 1:2, STR = c('a', 'b')),
     OM = matrix(1:12, ncol = 4))
```

```
## $WT
##   NUM STR
## 1   1   a
## 2   2   b
## 
## $OM
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
```

---

## Wake up slide!

- print actual time
- create a list "bad_list" with 3 positions:
    - **name** = "na"   |||   **values** = 3x NA
    - **name** = "chars"   |||    **values** = "a", "b", "c"
    - **name** = "bools"   |||    **values** = 2x FALSE and 1x TRUE
- create a data frame "happy_frame" with similar specification as in previous point:
    - 3 columns "na", "chars", "bools"
    - 3 rows

---
class: middle, inverse

# Arithmetic &amp; logic operators

---

## Arithmetic operators


```r
2 + 7
```

```
## [1] 9
```

```r
x = 2; y = 7
x + y
```

```
## [1] 9
```

```r
y - x
```

```
## [1] 5
```

```r
y^x
```

```
## [1] 49
```

```r
y/x
```

```
## [1] 3.5
```

---

## Arithmetics operators cont


```r
x = 2; y = 7
y %% x
```

```
## [1] 1
```

```r
y %/% x
```

```
## [1] 3
```

---

## Arithmetic functions


```r
x = 1:10
sqrt(x) # log(), exp(), sin(), ...
```

```
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
```

```r
sum(x)
```

```
## [1] 55
```

```r
mean(x) # median(), quantile(), ...
```

```
## [1] 5.5
```

---

## Arithmetic functions cont.


```r
summary(x) # can be used on data.frame and many other types 
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    3.25    5.50    5.50    7.75   10.00
```

---

## Sequences


```r
x = 6; y = 15
x:y
```

```
##  [1]  6  7  8  9 10 11 12 13 14 15
```

```r
seq(x, y, by = 2.5)
```

```
## [1]  6.0  8.5 11.0 13.5
```

```r
seq_len(y)
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
```

```r
seq_along(x:y)
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
rep(y, x)
```

```
## [1] 15 15 15 15 15 15
```

---

## Logic operators


```r
TRUE &amp; FALSE
```

```
## [1] FALSE
```

```r
c(T, F) &amp; T
```

```
## [1]  TRUE FALSE
```

```r
c(T, F) &amp;&amp; T
```

```
## [1] TRUE
```

```r
T | F
```

```
## [1] TRUE
```

```r
!F
```

```
## [1] TRUE
```

---

## Comparison


```r
"a" == "b"
```

```
## [1] FALSE
```

```r
2 != 5
```

```
## [1] TRUE
```

```r
2 %in% 1:5
```

```
## [1] TRUE
```

```r
3.985 &lt; 7
```

```
## [1] TRUE
```

```r
5.61 &gt;= 5.61
```

```
## [1] TRUE
```

---

## Wake up slide 2!

- write the commands that will calculate the length of numeric vector "input",
using arithmetic operators and functions only
- write the commands that will output boolean vector with TRUE for every 3rd position of the vector and FALSE for every other position using arithmetic &amp; comparison operators
- given the following input, return boolean vector indicating whether the fruit is:
  - red fruit larger than 5
  - non-red fruit smaller than 5

```r
fruit_size = c(2, 4, 7, 5, 3, 2)
fruit_col = c('g', 'y', 'r', 'g', 'b', 'r')
```

---
class: middle, inverse

# Subsetting (slicing)

---

## Names (indexing)
- vectors, lists can have position names
- data.frames and matrices can have rownames and colnames


```r
c(a = 3, "b" = 4)
```

```
## a b 
## 3 4
```

```r
namevec = 1:3
names(namevec) = c('a', 'b', 'c'); namevec
```

```
## a b c 
## 1 2 3
```

```r
list(g = 1, "h" = "R is very kind")
```

```
## $g
## [1] 1
## 
## $h
## [1] "R is very kind"
```

---

## Names cont.


```r
namemat = matrix(1:4, 2)
colnames(namemat) = c("eq.1","eq.2")
rownames(namemat) = c("x","y")
namemat
```

```
##   eq.1 eq.2
## x    1    3
## y    2    4
```

```r
namedf = data.frame("a" = 1L:3L, b = c('a','b','c'))
rownames(namedf) = c("Jana","Mirka","Lisa")
namedf
```

```
##       a b
## Jana  1 a
## Mirka 2 b
## Lisa  3 c
```

---

## Slicing in general
- can be done via three specifications
  - numeric position, e.g. third, fifth and seventh position
  - names, e.g. position 'Jana' and 'Mirka'
  - boolean, e.g. TRUE, FALSE, TRUE (same as the first and third position)

---

### Slicing vectors


```r
testvec = 1:6
names(testvec) = c("a", 'b', "c", "d", 'e', "f")
testvec[2]
```

```
## b 
## 2
```

```r
testvec[c(3,5)]
```

```
## c e 
## 3 5
```

```r
testvec[1:3]
```

```
## a b c 
## 1 2 3
```

```r
testvec[c('a','d')]
```

```
## a d 
## 1 4
```

---

### Slicing vectors cont.


```r
testvec[testvec &lt; 4]
```

```
## a b c 
## 1 2 3
```

```r
sec_vec = 6:1
testvec[sec_vec &lt; 4]
```

```
## d e f 
## 4 5 6
```

---

### Slicing lists


```r
testlist = list(a = matrix(2,1), "b" = c("R","is very kind"), c = T, d = NA)
testlist[c(2, 4)]
```

```
## $b
## [1] "R"            "is very kind"
## 
## $d
## [1] NA
```

```r
testlist[c('c','a')]
```

```
## $c
## [1] TRUE
## 
## $a
##      [,1]
## [1,]    2
```

---

### Slicing lists cont.


```r
testlist[1]
```

```
## $a
##      [,1]
## [1,]    2
```

```r
testlist[[1]]
```

```
##      [,1]
## [1,]    2
```

```r
# alternatively
testlist$a
```

```
##      [,1]
## [1,]    2
```

```r
testlist[[2]][1]; testlist$b[1]
```

```
## [1] "R"
```

```
## [1] "R"
```

---

### Slicing matrices


```r
namemat
```

```
##   eq.1 eq.2
## x    1    3
## y    2    4
```

```r
# no dollar notation
# names hard to use
namemat[2,c(1, 2)]
```

```
## eq.1 eq.2 
##    2    4
```

```r
namemat[c(1, 2), 2]
```

```
## x y 
## 3 4
```

---

### Slicing data.frames


```r
namedf
```

```
##       a b
## Jana  1 a
## Mirka 2 b
## Lisa  3 c
```

```r
namedf[1,c(1,2)]
```

```
##      a b
## Jana 1 a
```

```r
namedf[2,'a']
```

```
## [1] 2
```

```r
namedf['Jana','b']
```

```
## [1] a
## Levels: a b c
```

---

### Slicing data.frames cont.


```r
namedf[c('Jana','Mirka'), c('a','b')]
```

```
##       a b
## Jana  1 a
## Mirka 2 b
```

```r
namedf$a
```

```
## [1] 1 2 3
```

```r
namedf$b[1]
```

```
## [1] a
## Levels: a b c
```

```r
namedf[namedf$a &lt; 2,]
```

```
##      a b
## Jana 1 a
```

---

## Wake up slide 3!
- load mtcars dataset
  - slice rows where column **carb** is less than or equal to 2
  - choose rows **3, 8, 12**
  - sum the values of column **disp**
- create a list using the following script
  - slice the fifth row of the third column from data.frame (using [] notation)
  - slice the eight position of the 'drat' columns (using $ notation)

```r
test = list(a = mtcars)
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
